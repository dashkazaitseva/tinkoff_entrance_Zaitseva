# -*- coding: utf-8 -*-
"""task_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jur2WVAY-08zVpyiA8P9r2uBdl2QQvXB

**Формулировка задачи**

В вашем распоряжении имеется информация о стоимости акций компании в каждый момент времени в течение двух лет. Вам необходимо разработать алгоритм, который предложит стратегию покупки-продажи акций, позволяющую извлечь наибольшую прибыль.

Данная задача имеет различные «уровни сложности»: 

*   Возможно совершить максимум одну транзакцию покупки-продажи

*   Возможно совершить до двух транзакций покупки-продажи, но нельзя накапливать акции в портфеле, то есть каждый раз перед покупкой вы должны сначала продать все имеющиеся акции.
*  Возможно совершить до K транзакций, но нельзя накапливать акции в портфеле, то есть каждый раз перед покупкой вы должны сначала продать все имеющиеся акции. Капитал, передаваемый в ваше распоряжение, вводится с клавиатуры.



Во всех подзадачах необходимо вывести подробную информацию о стратегии и получаемой прибыли: 
вывести дату покупки, дату продажи и изменение стоимости акций в портфеле в каждый промежуток времени между покупкой и продажей.
"""

import pandas as pd

stock = pd.read_csv("new.csv")
stock.rename(columns={'Unnamed: 0' : 'i'}, inplace=True)
stock['i'] = range(len(stock))

stock.head()

"""Метод demonstration (используется во всех подзадача): вывод ответа в нужном формате."""

def sho(cur_i):
    dat = stock.at[cur_i, 'date']
    tim = stock.at[cur_i, 'time']
    pric =  stock.at[cur_i, 'price']
    print(dat, tim, pric)

def demonstration(a):
    it = 0
    sta = 0
    f_ind = a[0]
    l_ind = a[-1]
    for i in range(f_ind, l_ind + 1):
        if (i == a[it]):
            if sta == 0:
                print('Покупка', end = ' ')
            else:
                print('Продажа', end = ' ')
                it += 1
                sta ^= 1
        sho(i)

"""**Подзадача 1**

*Алгоритм*: для максимальной выгоды ищем пару моментов такую, что (стоимость акции в момент 2 / стоимость акции в момент 1) максимально. Для этого храним в память l, r - минимальная и максимальная стоиость до текущей строки. Если в просматриваемой строке значение больше - пробуем обновить ответ. Если меньше - обновляем текущий минимум.
"""

l = 0
r = 0
ans1, ans2 = 0, 0
for j in range(len(stock)):
    if (stock.at[j, 'price']< stock.at[l, 'price']):
        if (stock.at[ans2, 'price']/ stock.at[ans1, 'price'] < stock.at[r, 'price']/ stock.at[l, 'price']):
            ans1, ans2 = l, r
            l = j
            r = j
    if (stock.at[j, 'price']>stock.at[r, 'price']):
        r = j
        if (stock.at[ans2, 'price']/ stock.at[ans1, 'price'] < stock.at[r, 'price']/ stock.at[l, 'price']):
            ans1, ans2 = l, r
if (ans1 == ans2):
    print('Нет выигрышной стратегии, стоимость невозрастает')
else:
    demonstration([ans1, ans2])

"""**Подзадача 2**

*Алгоритм*: пусть d(4) - выгодные состояния до момента i, где d[0] - одна покупка, d[1] - пара покупка-продажа, d[2] - покупка-продажа-покупка, d[3] - покупка-продажа - покупка-продажа.

Очевидно, что заканчивать на продаже невыгодно, поэтому мы ищем максимум среди d[1], d[3]
"""

def check(b):
    ans = 1
    for i in range(len(b)):
        if i % 2 == 0:
            ans /= stock.at[b[i], 'price']
        else:
            ans *= stock.at[b[i], 'price']
    return ans

d = [[-1]] * 4

for i in range(len(stock)):
    for j in range(3, 0, -1):
        if (d[j - 1] != [-1] and (d[j] == [-1] or check(d[j]) < check(d[j - 1] + [i]))):
            d[j] = d[j - 1].copy()
            d[j].append(i)       
    if (d[0] == [-1] or stock.at[i, 'price'] < stock.at[d[0][0], 'price'] and d[0] != [-1]):
        d[0] = [i]
ans = [-1]
ans_check = 1
for i in range(1, 4, 2):
    if (d[i] != [-1]):
        cur = check(d[i])
        if (cur > ans_check):
            ans_check = cur
            ans = d[i]
demonstration(ans)

"""**Подзадача 3**

*Алгоритм*: пусть d(2*k) - выгодные состояния до момента i, где d[0] - одна покупка, d[1] - пара покупка-продажа, d[2] - покупка-продажа-покупка, d[3] - покупка-продажа - покупка-продажа, .. d[2*k-3] - (k-1) покупка-продажа.

Очевидно, что заканчивать на продаже невыгодно, поэтому мы ищем максимум среди d с нечетными индексами. 

Да - тут надо было учитывать еще и начальный капитал - я не справилась.
Но если предположить, что их оооочень много - все работает. 
"""

d = [[-1]] * 4

for i in range(len(stock)):
    for j in range(2*k - 1, 0, -1):
        if (d[j - 1] != [-1] and (d[j] == [-1] or check(d[j]) < check(d[j - 1] + [i]))):
            d[j] = d[j - 1].copy()
            d[j].append(i)       
    if (d[0] == [-1] or stock.at[i, 'price'] < stock.at[d[0][0], 'price'] and d[0] != [-1]):
        d[0] = [i]
ans = [-1]
ans_check = 1
for i in range(1, 2*k, 2):
    if (d[i] != [-1]):
        cur = check(d[i])
        if (cur > ans_check):
            ans_check = cur
            ans = d[i]
demonstration(ans)